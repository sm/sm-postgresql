#!/usr/bin/env bash

#
# pgha - PostgreSQL High Availability Monitor
#
# NOTES:
# - ${PGDATA}/pgha/master file with master IP address 
#   must be put in place by the provisioner
# - This script runs under the postgresql user as a minutely cronjob:
#
#    * * * * * PGDATA=/var/db/postgresql/9.3/data /opt/sm/bin/sm pgha run
#
# - To run manually in debug mode as user postgres:
# 
#   DEBUG=1 PGDATA=/var/db/postgresql/9.3/data sm pgha run
#
# TODO: 
# - vmotion master comes back online safely.
# - multiple failures including both master and sync.
#
# Questions:
#  - Should we save the original MasterIP when sync is promoted?  Not unless we want to report back 
#    to some central authority that the server pool lost a server
#
# Keep track of where we go next.
#

typeset timestamp masterFile syncFile replicasFile replicatingFile myRole pghaPath syncIP masterIP firstReplica
declare -a replicaIPs myIPs

export PATH="/bin:/usr/bin:/sbin:/usr/sbin:/opt/sm/pkg/active/bin:/usr/local/bin"

timestamp=$(date +"%Y-%m-%dT%H:%M:%S")
pghaPath=${PGDATA}/../pgha
# Other options of where we could put pghaPath include,
# pghaPath=${HOME}/pgha
# pghaPath=${TMP}/pgha

exec &> ${pghaPath}/pgha.log
echo "${timestamp}"

if (( ${DEBUG} ))
then set -x
fi

if [[ $USER != 'postgres' ]]
then echo "pgha must be run as user 'postgres'"
fi

masterFile=${pghaPath}/master
syncFile=${pghaPath}/sync
replicasFile=${pghaPath}/replicas
replicatingFile=${pghaPath}/replicating
masterIP=$(cat ${masterFile})
syncIP=$(cat ${syncFile})
replicaIPs=($(cat ${replicasFile}))

#If the server from the last run is still in the process of replicating, abort this process
if [[ -s ${replicatingFile} ]] 
then exit 0
fi

if [[ -z ${masterIP} ]]
then
  echo "ERROR: pgha can not run, a master IP has not been set in ${masterFile}"
  exit 1
fi

myIPs=($(ip addr list | awk '/inet / && /eth*/ &&!/127.0.0.1/{print $2}' | sed -e 's|/.*$||'))

loadIPs() {
  local _ipSQL _syncSQL _replicaSQL
  if [[ -n ${masterIP} ]]
  then
    ipSQL="SELECT client_addr FROM pg_stat_replication "
    syncSQL="${_ipSQL} WHERE sync_state='sync';"
    replicaSQL="${_ipSQL} WHERE sync_state='potential' ORDER BY client_addr DESC;"
    syncIP=$(psql -h "${masterIP}" postgres -t -A -c "${_syncSQL}")
    replicaIPs=($(psql -h "${masterIP}" postgres -t -A -c "${_replicaSQL}"))
  fi
}

isResponsive() {
  local _ip
  _ip=${1}
  if ${_ip}
  then 
    echo "ERROR: isResponsive called without ip!"
    return 1
  fi
  if psql -h ${1} postgres -t -A -c "select 'master is online';"
  then return 0
  else return 1
  fi
}

saveIPs() {
  mkdir -p ${pghaPath} # Because replication eliminates this dir.
  echo ${masterIP} > ${masterFile}
  echo ${syncIP} > ${syncFile}
  echo ${replicaIPs[*]} > ${replicasFile}
}

setMyRole() {
  myRole="new"
  for addr in ${myIPs[@]}
  do 
    if [[ ${addr} == ${masterIP} ]] 
    then 
      myRole="master"
      break
    fi
    if [[ ${addr} == ${syncIP} ]] 
    then 
      myRole="sync"
      break
    fi
    for replicaIP in ${replicaIPs[@]}
    do
      if [[ ${addr} == ${replicaIP} ]] 
      then 
        myRole="replica"
        break
      fi
    done
  done
  return 0
}

replicateFromMaster() {
  local _status
  echo $$ > ${replicatingFile}
  if /opt/sm/bin/sm postgresql replication configure master "${masterIP}"
  then _status=0
  else _status=1
  fi
  # Need to guarantee the replicating file is removed and the master IP is saved
  # Hence the if statement above to catch every case.
  rm -f ${replicatingFile}
  return ${_status}
}

isReplicating() {
  local _ip
  _ip="${1}"
  readOnly=$(psql -h "${_ip}" postgres -t -A -c "SHOW transaction_read_only;")
  if [[ ${readOnly} == "on" ]]
  then return 0
  else return 1
  fi
}

promoteToMaster() {
  #touch ${PGDATA}/failover
  /opt/sm/bin/sm postgresql replication promote
  masterIP=${syncIP}
  syncIP=""
  replicaIPs=""
}

if isResponsive ${masterIP}
then loadIPs
fi

setMyRole

case ${myRole} in
  (master)
    saveIPs
    ;;
  (sync)
    if ! isResponsive ${masterIP}
    then promoteToMaster
    fi
    saveIPs
    ;;
  (replica)
    if isResponsive ${masterIP}
    then 
      saveIPs
    elif [[ -n ${syncIP} ]] && isResponsive ${syncIP}
    then 
      masterIP=${syncIP}
      replicateFromMaster
      loadIPs
      saveIPs
    else # master and sync replica are offline...
      if (( ${#replicaIPs} == 1 ))
      then # I am a replica and no other replicas exist.
        promoteToMaster
      elif  (( ${#replicaIPs} > 1 ))
      then
        firstReplica=${replicaIPs[1]}
        if isResponsive ${firstReplica}
        then
          masterIP=${firstReplica}
          if replicateFromMaster
          then
            loadIPs
            saveIPs
          fi
        fi
      fi
    fi
    ;;
  (new)
    if replicateFromMaster
    then
      loadIPs
      saveIPs
    fi
    ;;
esac

exit $? # Let cron kickoff in one minute instead of sleeping
