#!/bin/sh

parse_args() {
  declare -a new_args
  while (( ${#extension_args} > 0 ))
  do
    array shift extension_args into token
    case ${token} in
      (pgha)
        continue
        ;;
      (master)
        array shift extension_args into master_ip
        ;;
      (pgdata)
        array shift extension_args into PGDATA
        ;;
      (tags)
        declare -a tgs
        array shift extension_args into tgs
        tags=($(echo $tgs | tr ',' ' '))
        ;;
      (etcd_ip)
        array shift extension_args into etcd_ip
        ;;
      (etcd_port)
        array shift extension_args into etcd_port
        ;;
      (my_ip)
        array shift extension_args into my_ip
        ;;
      (debug)
        DEBUG=1
        ;;
      (*)
        if variable is nonempty token
        then new_args+=("${token}")
        fi
        ;;
    esac
  done
  extension_args=("${new_args[@]}")
}

loadIPs() {
  local _ipSQL _syncSQL _replicaSQL
  if [[ -n ${master_ip} ]]
  then
    _ipSQL="SELECT client_addr FROM pg_stat_replication "
    _syncSQL="${_ipSQL} WHERE sync_state='sync';"
    _replicaSQL="${_ipSQL} WHERE sync_state='potential' ORDER BY client_addr DESC;"
    sync_ip=$(psql -h "${master_ip}" postgres -t -A -c "${_syncSQL}")
    replica_ips=($(psql -h "${master_ip}" postgres -t -A -c "${_replicaSQL}"))
  fi
}

isResponsive() {
  local _ip
  _ip=${1}
  if [[ -z ${_ip} ]]
  then 
    echo "ERROR: isResponsive called without ip!"
    return 1
  fi

  if psql -h ${_ip} postgres -t -A -c "select '${_ip} is responsive';"
  then return 0
  else return 1
  fi
}

saveIPs() {
  mkdir -p ${pghaPath} # Ensure the pgha path exists
  echo ${master_ip} > ${masterFile}
  echo ${sync_ip} > ${syncFile}
  echo ${replica_ips[*]} > ${replicasFile}
}

saveToEtcd() {
  #curl -L http://${master_ip}:4001/v2/keys/pgha/master/ip -XPUT -d value="${master_ip}" -d ttl=120
  #curl -L http://${master_ip}:4001/v2/keys/pgha/sync/ip -XPUT -d value="${sync_ip}" -d ttl=120
  #curl -L http://${master_ip}:4001/v2/keys/pgha/asyncs/ips -XPUT -d value="${replica_ips[*]}" -d ttl=120
  etcd_ctl set pgha/master/ip "${master_ip}"
  etcd_ctl set pgha/sync/ip "${sync_ip}"
  etcd_ctl set pgha/asyncs/ips "${replica_ips[*]}"
}

setMyRole() {
  myRole="new"
  for addr in ${my_ips[@]}
  do 
    if [[ ${addr} == ${master_ip} ]] 
    then 
      myRole="master"
      break
    fi

    if [[ ${addr} == ${sync_ip} ]] 
    then 
      myRole="sync"
      break
    fi

    for replicaIP in ${replica_ips[@]}
    do
      if [[ ${addr} == ${replicaIP} ]] 
      then 
        myRole="replica"
        break
      fi
    done
  done
  return 0
}

replicateFromMaster() {
  local _status
  echo $$ > ${replicatingFile}

  if /opt/sm/bin/sm postgresql replication configure master "${master_ip}"
  then _status=0
  else _status=1
  fi
  # Need to guarantee the replicating file is removed and the master IP is saved
  # Hence the if statement above to catch every case.
  rm -f ${replicatingFile}
  return ${_status}
}

isReplicating() {
  local _ip
  _ip="${1}"

  readOnly=$(psql -h "${_ip}" postgres -t -A -c "SHOW transaction_read_only;")

  if [[ ${readOnly} == "on" ]]
  then return 0
  else return 1
  fi
}

promoteToMaster() {
  #touch ${PGDATA}/failover
  /opt/sm/bin/sm postgresql replication promote
  master_ip=${sync_ip}
  sync_ip=""
  replica_ips=()
}

replicationIsStarting() {
  if [[ -s ${replicatingFile} ]] 
  then return 0
  else return 1
  fi
}

read_config_defaults() {
  config read file defaults key etcd_ip from pgha
  config read file defaults key etcd_port from pgha
}

etcd_ctl() {
  etcdctl -C ${etcd_ip}:${etcd_port} "$@"
}

ips_from() {
  if [[ -s $1 ]]
  then sed -n 's/server \(.*\):.*/\1/p' $* | sort
  fi
}

read_pgha_ips() {
  master_ip=$(etcd_ctl get pgha/master/ip)
  sync_ip=$(etcd_ctl get pgha/sync/ip)
  async_ips=($(etcd_ctl get pgha/async/ips | sort))
  replica_ips=(${sync_ip} ${async_ips[@]})
  current_master=$(ips_from /etc/nginx/tcp/upstreams/master)
  current_sync=$(ips_from /etc/nginx/tcp/upstreams/sync)
  current_async=$(ips_from /etc/nginx/tcp/upstreams/async)
}

require_postgres_user() {
  # TODO: IF user is root, re-exec as postgres
  if [[ $USER != 'postgres' ]]
  then log error "this pgha action must be run as user 'postgres'"
  fi
}

require_root_user() {
  # TODO: IF user is root, re-exec as postgres
  if (( UID > 0 ))
  then log error "this pgha action must be run as user 'root'"
  fi
}


require_etcd_ip() {
  if [[ -z ${etcd_ip} ]]
  then log error "ERROR: ${etcd_ip} must be given or set."
  fi
}

require_pgdata() {
  if [[ -z ${PGDATA} ]]
  then log error "environment variable 'PGDATA' must be set."
  fi
}

require_master_ip() {
  if [[ -z ${master_ip} ]]
  then log fail "'master <ip>' must be set in etcd."
  fi
}
